<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Elasticsearch Script的使用</title>
</head>
<body>
<p><img src="深入了解 Elasticsearch 8.1 中的 Script 使用.assets\image-20231025100819430.png" referrerpolicy="no-referrer" alt="image-20231025100819430"></p>
<h1 id='一什么是-elasticsearch-script'>一、什么是 Elasticsearch Script？</h1>
<p><code>Elasticsearch</code> 中的  <code>Script</code>  是一种灵活的方式，允许用户在查询、聚合和更新文档时执行自定义的脚本。这些脚本可以用来动态计算字段值、修改查询行为、执行复杂的条件逻辑等等。</p>
<h1 id='二支持的脚本语言有哪些'>二、支持的脚本语言有哪些</h1>
<p>支持多种脚本语言，包括 <strong>Painless</strong>、<strong>Expression</strong>、<strong>Mustache</strong>、<strong>Java</strong>等，其中默认的是<strong>Painless</strong>。</p>
<p><img src="深入了解 Elasticsearch 8.1 中的 Script 使用.assets\image-20231024120432403.png" referrerpolicy="no-referrer" alt="image-20231024120432403"></p>
<h1 id='三painless-脚本的使用'>三、Painless 脚本的使用</h1>
<p><strong>Painless</strong> 是一种专为 <strong>Elasticsearch</strong> 设计的脚本语言，具有安全、快速、简单的特点，使其在 <strong>Elasticsearch</strong> 中非常方便入门。</p>
<ol start='' >
<li><strong>安全性：</strong> <strong>Painless</strong> 被设计为一种安全的脚本语言。它采取了一系列的安全措施，如禁止无限循环、禁止访问 <strong>Java</strong> 类库中的危险类等，以减轻潜在的安全风险。</li>
<li><strong>高性能：</strong> <strong>Painless</strong> 是为高性能而设计的，特别是在 Elasticsearch 中。它经过了优化，可以在大规模数据集上快速执行。</li>
<li><strong>易学易用：</strong> <strong>Painless</strong> 实现了任何具有基本编码经验的人都自然熟悉的语法。<strong>Painless</strong> 使用 Java 语法的子集，并进行了一些额外的改进，以增强可读性并删除样板文件。</li>
<li><strong>无需编译：</strong> <strong>Painless</strong> 脚本不需要预先编译。它可以在运行时解释，所以我们可以动态调整脚本而无需重新编译整个应用程序。</li>
<li><strong>支持参数化：</strong> <strong>Painless</strong> 允许在脚本中使用参数，这可以使脚本更通用，适用于多种情况。参数化脚本可以接受外部传递的值，从而在不修改脚本的情况下改变其行为。</li>
<li><strong>支持多种数据类型：</strong> <strong>Painless</strong> 支持多种数据类型，包括数字、字符串、日期、布尔值等。</li>
<li><strong>集成性：</strong> <strong>Painless</strong> 被紧密集成到 <strong>Java</strong> 中，可以用于查询、聚合、脚本字段、脚本排序等各种用例。</li>

</ol>
<h2 id='31编写我们的第一个脚本'>3.1、编写我们的第一个脚本</h2>
<blockquote><p>使用的 <code>Elasticsearch</code> 版本为 <code>8.1</code>，历史文章除非特别说明，最近更文的 <code>ES</code>版本都为 <code>Elasticsearch</code> 的 <code>8.1</code> 版本</p>
</blockquote>
<p>脚本的组成有三个参数，只要是在 <strong>Elasticsearch</strong> <strong>API</strong> 支持脚本的地方，都可以使用如下三个参数来使用脚本。</p>
<pre><code class='language-text' lang='text'> &quot;script&quot;: {
    &quot;lang&quot;:   &quot;...&quot;,
    &quot;source&quot; | &quot;id&quot;: &quot;...&quot;,
    &quot;params&quot;: { ... }
  }
</code></pre>
<ul>
<li><code>lang</code>：执行脚本语言类型，默认<code>painless</code></li>
<li><code>source，id</code>：脚本的源码本身，或者提前存储的<code>脚本ID</code></li>
<li><code>params</code>：作为变量传递给脚本的参数</li>

</ul>
<p>下面我们将通过实际的例子来进行说明</p>
<h2 id='32在检索中使用脚本'>3.2、在检索中使用脚本</h2>
<ul>
<li><p>首先我们先往索引中插入一篇文档</p>
<pre><code class='language-text' lang='text'>PUT zfc-doc-000007/_doc/1
{
  &quot;sum&quot;: 5,
  &quot;message&quot;:&quot;test painless&quot;
}
</code></pre>
</li>
<li><p>使用脚本实现<code>sum</code>的值 <code>乘2</code>，此处使用变量 <code>multiplie</code>r，在脚本的参数中指定参数值为<code>2</code>，其中<code>doc[&#39;sum&#39;].value * params[&#39;multiplier&#39;]</code>的意思就是获取文档中<code>sum</code>的值并乘以脚本中 <code>multiplier</code>的值</p>
<pre><code class='language-text' lang='text'>GET zfc-doc-000007/_search
{
  &quot;script_fields&quot;: {
    &quot;my_doubled_field&quot;: {
      &quot;script&quot;: { 
        &quot;source&quot;: &quot;doc[&#39;sum&#39;].value * params[&#39;multiplier&#39;]&quot;, 
        &quot;params&quot;: {
          &quot;multiplier&quot;: 2
        }
      }
    }
  }
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>在获取脚本的参数中的变量值除了使用<code>params[&#39;参数名&#39;]</code>这种方式之外，还可以使用<code>params.get(&#39;multiplier&#39;)</code>方法获取</p>
<pre><code class='language-text' lang='text'>GET zfc-doc-000007/_search
{
  &quot;script_fields&quot;: {
    &quot;my_doubled_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;painless&quot;,
        &quot;source&quot;: &quot;doc[&#39;sum&#39;].value * params.get(&#39;multiplier&#39;);&quot;,
        &quot;params&quot;: {
          &quot;multiplier&quot;: 2
        }
      }
    }
  }
}
</code></pre>
</li>

</ul>
<p>上面我们是在检索请求中使用的脚本字段来使用的脚本，下面我们先内置一个脚本，通过使用<code>脚本ID</code>来使用内置的脚本</p>
<h2 id='33使用内置的脚本'>3.3、使用内置的脚本</h2>
<ul>
<li><p>创建一个脚本<code>calculate-score</code>，它可以使用<code>Math.log(_score * 2) + params[&#39;my_modifier&#39;]</code>修改分数值</p>
<pre><code class='language-text' lang='text'>POST _scripts/calculate-score
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;Math.log(_score * 2) + params[&#39;my_modifier&#39;]&quot;
  }
}

</code></pre>
<p>&nbsp;</p>
</li>
<li><p>创建完成的脚本我们可以使用<code>_script</code>API查看脚本的内容</p>
<pre><code class='language-text' lang='text'>GET _scripts/calculate-score
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>在检索中只需要如下指定<code>脚本的ID</code>即可进行检索时使用</p>
<pre><code class='language-text' lang='text'>GET zfc-doc-000007/_search
{
  &quot;query&quot;: {
    &quot;script_score&quot;: {
      &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;message&quot;: &quot;painless&quot;
        }
      },
      &quot;script&quot;: {
        &quot;id&quot;: &quot;calculate-score&quot;, 
        &quot;params&quot;: {
          &quot;my_modifier&quot;: 2
        }
      }
    }
  }
}
</code></pre>
</li>
<li><p>如果想删除脚本只需要调用<code>DELETE</code>即可</p>
<pre><code class='language-text' lang='text'>DELETE _scripts/calculate-score
</code></pre>
</li>

</ul>
<p>下面我们再来演示一下如何使用脚本更新文档中的内容</p>
<h2 id='34使用脚本操作文档'>3.4、使用脚本操作文档</h2>
<ul>
<li><p>先添加一个文档来进行测试</p>
<pre><code class='language-text' lang='text'>PUT zfc-doc-000007/_doc/1
{
  &quot;counter&quot; : 1,
  &quot;tags&quot; : [&quot;red&quot;]
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>使用脚本对文档中的 <code>counter</code> 的值与脚本中的 <code>count</code>值进行相加</p>
<pre><code class='language-text' lang='text'>
POST zfc-doc-000007/_update/1
{
  &quot;script&quot; : {
    &quot;source&quot;: &quot;ctx._source.counter += params.count&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot; : {
      &quot;count&quot; : 4
    }
  }
}
</code></pre>
</li>
<li><p>我们还可以对文档中的数组类型的<code>tags</code>字段进行增加子对象，比如增加一个<code>blue</code></p>
<pre><code class='language-text' lang='text'>POST zfc-doc-000007/_update/1
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.tags.add(params[&#39;tag&#39;])&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot;: {
      &quot;tag&quot;: &quot;blue&quot;
    }
  }
}
</code></pre>
</li>
<li><p>使用脚本对文档中的 <code>tags</code> 的值进行删除，条件就是当 <code>tag</code> 的值与脚本中的值相等时删除。如下为当 <code>tags</code> 的值为<code>blue</code>时，删除<code>blue</code></p>
<pre><code class='language-text' lang='text'>POST zfc-doc-000007/_update/1
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;if (ctx._source.tags.contains(params[&#39;tag&#39;])) { ctx._source.tags.remove(ctx._source.tags.indexOf(params[&#39;tag&#39;])) }&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot;: {
      &quot;tag&quot;: &quot;blue&quot;
    }
  }
}
</code></pre>
</li>
<li><p>上面只是对已有字段的增加删除修改，下面还可以使用脚本进行新字段的增加，比如增加一个字段<code>new_field</code>，值是<code>value_of_new_field</code></p>
<pre><code class='language-text' lang='text'>POST zfc-doc-000007/_update/1
{
  &quot;script&quot; : &quot;ctx._source.new_field = &#39;value_of_new_field&#39;&quot;
}
</code></pre>
</li>
<li><p>上面是字段的增加，下面就是字段的移除</p>
<pre><code class='language-text' lang='text'>POST zfc-doc-000007/_update/1
{
  &quot;script&quot; : &quot;ctx._source.remove(&#39;new_field&#39;)&quot;
}
</code></pre>
</li>
<li><p>除了对字段的删除，数组对象内部值的删除，还可以对文档进行删除。如下，当 <code>tags</code> 里面包含 <code>blue</code> 时，删除当前文档</p>
<pre><code class='language-text' lang='text'>POST zfc-doc-000007/_update/1
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;if (ctx._source.tags.contains(params[&#39;tag&#39;])) { ctx.op = &#39;delete&#39; } else { ctx.op = &#39;none&#39; }&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot;: {
      &quot;tag&quot;: &quot;blue&quot;
    }
  }
}
</code></pre>
</li>

</ul>
<p>&nbsp;</p>
<h2 id='35使用脚本解析日志信息'>3.5、使用脚本解析日志信息</h2>
<p>所谓的解析字符串，只是一组固定格式的字符串，提前使用变量的形式编译，在插入文档时，通过脚本进行解析保存，方便后面的检索等请求</p>
<p>假如我们有如下数据</p>
<pre><code class='language-text' lang='text'>&quot;message&quot; : &quot;247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \&quot;GET /images/hm_nbg.jpg HTTP/1.0\&quot; 304 0&quot;
</code></pre>
<p>那么我们可以使用如下变量的形式解析该字符串</p>
<pre><code class='language-text' lang='text'>%{clientip} %{ident} %{auth} [%{@timestamp}] \&quot;%{verb} %{request} HTTP/%{httpversion}\&quot; %{status} %{size}
</code></pre>
<p>下面我们使用例子来说明脚本解析字符串之后是何种形式的存在</p>
<ul>
<li><p>创建一个索引保存解析的数据</p>
<pre><code class='language-text' lang='text'>PUT zfc-doc-000008
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;message&quot;: {
        &quot;type&quot;: &quot;wildcard&quot;
      }
    }
  }
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>内置一个脚本，实现解析字符串信息，并提取需要的信息，如下为提取当前日志中的 <code>http</code> 响应信息<code>response</code>，对于如下脚本的<strong>测试API</strong>使用详情可以参考官网</p>
<blockquote><p><a href='https://www.elastic.co/guide/en/elasticsearch/painless/8.1/painless-execute-api.html' target='_blank' class='url'>https://www.elastic.co/guide/en/elasticsearch/painless/8.1/painless-execute-api.html</a></p>
</blockquote>
<pre><code class='language-text' lang='text'>POST /_scripts/painless/_execute
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;&quot;&quot;
      String response=dissect(&#39;%{clientip} %{ident} %{auth} [%{@timestamp}] &quot;%{verb} %{request} HTTP/%{httpversion}&quot; %{response} %{size}&#39;).extract(doc[&quot;message&quot;].value)?.response;
        if (response != null) emit(Integer.parseInt(response)); 
    &quot;&quot;&quot;
  },
  &quot;context&quot;: &quot;long_field&quot;, 
  &quot;context_setup&quot;: {
    &quot;index&quot;: &quot;zfc-doc-000008&quot;,
    &quot;document&quot;: {          
      &quot;message&quot;: &quot;&quot;&quot;247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] &quot;GET /images/hm_nbg.jpg HTTP/1.0&quot; 304 0&quot;&quot;&quot;
    }
  }
}
</code></pre>
</li>

</ul>
<p>如果我们还想操作当前解析的数据我们可以使用运行时字段，因为运行时字段不需要进行索引会更加的灵活，可以很方便的修改脚本及运行方式。</p>
<ul>
<li><p>那么我们现在删除一下刚刚创建的索引，重新添加一下，创建语句如下</p>
<pre><code class='language-text' lang='text'>DELETE zfc-doc-000008
PUT /zfc-doc-000008
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;@timestamp&quot;: {
        &quot;format&quot;: &quot;strict_date_optional_time||epoch_second&quot;,
        &quot;type&quot;: &quot;date&quot;
      },
      &quot;message&quot;: {
        &quot;type&quot;: &quot;wildcard&quot;
      }
    }
  }
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>添加一个运行时字段来保存解析的结果</p>
<pre><code class='language-text' lang='text'>PUT zfc-doc-000008/_mappings
{
  &quot;runtime&quot;: {
    &quot;http.response&quot;: {
      &quot;type&quot;: &quot;long&quot;,
      &quot;script&quot;: &quot;&quot;&quot;
        String response=dissect(&#39;%{clientip} %{ident} %{auth} [%{@timestamp}] &quot;%{verb} %{request} HTTP/%{httpversion}&quot; %{response} %{size}&#39;).extract(doc[&quot;message&quot;].value)?.response;
        if (response != null) emit(Integer.parseInt(response));
      &quot;&quot;&quot;
    }
  }
}
</code></pre>
</li>
<li><p>添加几条测试数据用于测试</p>
<pre><code class='language-text' lang='text'>POST /zfc-doc-000008/_bulk?refresh=true
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:30:17-05:00&quot;,&quot;message&quot;:&quot;40.135.0.0 - - [30/Apr/2020:14:30:17 -0500] \&quot;GET /images/hm_bg.jpg HTTP/1.0\&quot; 200 24736&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:30:53-05:00&quot;,&quot;message&quot;:&quot;232.0.0.0 - - [30/Apr/2020:14:30:53 -0500] \&quot;GET /images/hm_bg.jpg HTTP/1.0\&quot; 200 24736&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:31:12-05:00&quot;,&quot;message&quot;:&quot;26.1.0.0 - - [30/Apr/2020:14:31:12 -0500] \&quot;GET /images/hm_bg.jpg HTTP/1.0\&quot; 200 24736&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:31:19-05:00&quot;,&quot;message&quot;:&quot;247.37.0.0 - - [30/Apr/2020:14:31:19 -0500] \&quot;GET /french/splash_inet.html HTTP/1.0\&quot; 200 3781&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:31:22-05:00&quot;,&quot;message&quot;:&quot;247.37.0.0 - - [30/Apr/2020:14:31:22 -0500] \&quot;GET /images/hm_nbg.jpg HTTP/1.0\&quot; 304 0&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:31:27-05:00&quot;,&quot;message&quot;:&quot;252.0.0.0 - - [30/Apr/2020:14:31:27 -0500] \&quot;GET /images/hm_bg.jpg HTTP/1.0\&quot; 200 24736&quot;}
{&quot;index&quot;:{}}
{&quot;timestamp&quot;:&quot;2020-04-30T14:31:28-05:00&quot;,&quot;message&quot;:&quot;not a valid apache log&quot;}
</code></pre>
</li>
<li><p>下面我们进行运行时字段检索响应为<code>304</code>的数据</p>
<pre><code class='language-text' lang='text'>
GET zfc-doc-000008/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;http.response&quot;: &quot;304&quot;
    }
  },
  &quot;fields&quot; : [&quot;http.response&quot;]
}

</code></pre>
</li>
<li><p>刚才是属于提前内置好运行时字段，我们也可以直接在检索时指定运行时字段来使用，但下面所示的仅在运行时有效。如下所示</p>
<pre><code class='language-text' lang='text'>GET zfc-doc-000008/_search
{
  &quot;runtime_mappings&quot;: {
    &quot;http.response&quot;: {
      &quot;type&quot;: &quot;long&quot;,
      &quot;script&quot;: &quot;&quot;&quot;
        String response=dissect(&#39;%{clientip} %{ident} %{auth} [%{@timestamp}] &quot;%{verb} %{request} HTTP/%{httpversion}&quot; %{response} %{size}&#39;).extract(doc[&quot;message&quot;].value)?.response;
        if (response != null) emit(Integer.parseInt(response));
      &quot;&quot;&quot;
    }
  },
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;http.response&quot;: &quot;304&quot;
    }
  },
  &quot;fields&quot; : [&quot;http.response&quot;]
}
</code></pre>
</li>

</ul>
<p>我们也可以根据特定的值进行拆分，获取所需要的信息</p>
<h2 id='36使用脚本解析-gc-信息'>3.6、使用脚本解析 GC 信息</h2>
<ul>
<li><p>例如如下 <code>Elasticsearch</code> 的 <code>GC</code> 信息</p>
<pre><code class='language-text' lang='text'>[2021-04-27T16:16:34.699+0000][82460][gc,heap,exit]   class space    used 266K, capacity 384K, committed 384K, reserved 1048576K
</code></pre>
</li>
<li><p>下面我们根据 <code>GC</code> 信息编写一个解析模式</p>
<pre><code class='language-text' lang='text'>[%{@timestamp}][%{code}][%{desc}]  %{ident} used %{usize}, capacity %{csize}, committed %{comsize}, reserved %{rsize}
</code></pre>
</li>
<li><p>然后在检索时就可以使用如下语句来提交信息到运行时字段，首先添加测试数据，注意索引名称已经更换，解析模式不匹配会报错</p>
<pre><code class='language-text' lang='text'>
POST /zfc-doc-000010/_bulk?refresh
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-04-27T16:16:34.699+0000][82460][gc,heap,exit]   class space    used 266K, capacity 384K, committed 384K, reserved 1048576K&quot;}
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-03-24T20:27:24.184+0000][90239][gc,heap,exit]   class space    used 15255K, capacity 16726K, committed 16844K, reserved 1048576K&quot;}
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-03-24T20:27:24.184+0000][90239][gc,heap,exit]  Metaspace       used 115409K, capacity 119541K, committed 120248K, reserved 1153024K&quot;}
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-04-19T15:03:21.735+0000][84408][gc,heap,exit]   class space    used 14503K, capacity 15894K, committed 15948K, reserved 1048576K&quot;}
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-04-19T15:03:21.735+0000][84408][gc,heap,exit]  Metaspace       used 107719K, capacity 111775K, committed 112724K, reserved 1146880K&quot;}
{&quot;index&quot;:{}}
{&quot;gc&quot;: &quot;[2021-04-27T16:16:34.699+0000][82460][gc,heap,exit]  class space  used 266K, capacity 367K, committed 384K, reserved 1048576K&quot;}
</code></pre>
</li>
<li><p>使用检索语句展示解析数据到运行时字段中</p>
<pre><code class='language-text' lang='text'>GET zfc-doc-000010/_search
{
  &quot;runtime_mappings&quot;: {
    &quot;gc_size&quot;: {
      &quot;type&quot;: &quot;keyword&quot;,
      &quot;script&quot;: &quot;&quot;&quot;
        Map gc=dissect(&#39;[%{@timestamp}][%{code}][%{desc}]  %{ident} used %{usize}, capacity %{csize}, committed %{comsize}, reserved %{rsize}&#39;).extract(doc[&quot;gc.keyword&quot;].value);
        if (gc != null) emit(&quot;used&quot; + &#39; &#39; + gc.usize + &#39;, &#39; + &quot;capacity&quot; + &#39; &#39; + gc.csize + &#39;, &#39; + &quot;committed&quot; + &#39; &#39; + gc.comsize);
      &quot;&quot;&quot;
    }
  },
  &quot;size&quot;: 1,
  &quot;aggs&quot;: {
    &quot;sizes&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;gc_size&quot;,
        &quot;size&quot;: 10
      }
    }
  },
  &quot;fields&quot; : [&quot;gc_size&quot;]
}
</code></pre>
<p>&nbsp;</p>
</li>

</ul>
<p>通过上面的查询测试可以知道，<code>Elasticsearch</code> 中的 <code>script</code> 默认的时 <code>painless</code> 语言，功能已经非常强大可以满足我们的日常需求，如果还想更高级的脚本，可以使用 <code>Java</code> 语言来编写自己的脚本。关于 <code>Expressions</code> 的表达式的使用就参与官网吧，本文的所有例子均来自官网，并自测完成。如有错误欢迎指出，共同进步。</p>
<p>后面有机会会出现一片使用Java编译脚本的使用，等后面时间吧，最近这段时间听尴尬的，也托更很久了，以后慢慢的都要补上。</p>
<p>2023 最后俩月了，加油。</p>
<p>&nbsp;</p>
<p>原文链接</p>
<p><a href='https://www.elastic.co/guide/en/elasticsearch/reference/8.1/modules-scripting.html'>https://www.elastic.co/guide/en/elasticsearch/reference/8.1/modules-scripting.html</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>